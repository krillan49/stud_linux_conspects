echo "                                              Строки"

# Строки в shell - это по умолчанию любые введенные символы.

str="123abc" # присвоение строки в переменную



echo "                                        Методы информационные"

# ${#parameter} - длинна строки
echo ${#str} #=> 6

# =~ - оператор проверки соответсвия строки шаблону. Както криво работает в условном операторе
"$text" =~ '^[+-]?[0-9]+$'

# Получить ascii код символа
char="a"
ascii_value=$(printf "%d" "'$char")
echo $ascii_value #=> 97



echo "                                        Элементы и срезы строк"

# ${parameter:offset:length} - синтаксис срезов строки где:
# offset - индекс начала среза(или число элементов до среза ??)
# length - число символов в срезе
echo ${str:1}    #=> "23abc"
echo ${str:2:2}  #=> "3a"
echo ${str:0:1}  #=> "1"    # тоесть элемент с индексом 0
echo ${str:1:-1} #=> "23ab" # при отрицательном length убирается число элементов с конца строки

# Получить n-й символ строки:
first_letter=$(printf %.1s "abc")
echo "$first_letter" #=> 'a'

# Длинну и срезы можно использовать например в цикле
for (( i = 0; i < ${#str}; ++i)); do
  echo "${str:$i:1}"
done



echo "                                      Методы трансформации строк"

# tr - команда для замены посимвольно
echo "BAAACCC" | tr 'ABC' '123' #=> 2111333

# upper/lower case
echo $1 | tr [A-Z] [a-z]
echo $1 | tr 'a-z' 'A-Z'
echo "AbC" | tr '[:upper:]' '[:lower:]'  #=> 'abc'
echo "AbC" | awk '{print tolower($0)}'  #=> 'abc'

# ${str~~} - оператор bash для swapcase строки
in=AbCdE
echo ${in~~} #=> aBcDe

# rev - команда для реверсирования строки
echo "abc" | rev        #=> "cba"
FOO=$(echo $str | rev)  # поместить реверсированную строку в переменную



echo "                                    Удаление частей строк по шаблонам"

# Удалить 1й и последний символ строки при помощи команды sed и регулярок
echo '1234567' | sed -e 's/^.//' -e 's/.$//'    #=> '23456'

# Удаляем все пробелы с флагами "g" и "i"
echo "$1" | sed -e 's/ //gi'
echo "$1" | tr -d " "      # тоже самое
echo ${1// /}              # тоже самое
echo "${1//[aeiouAEIOU]/}" # удаляем все гласные

# Подстанока переменной в регулярку (удаляем все буквы кроме указанных)
str="fuck"
abc="abcdefghijklmnopqrstuvwxyz"
echo "${abc//[^$str]/}" #=> cfku



echo "                                    Конкатенация и мультипликация строк"

# Конкатенация строк через интерполяцию
foo="Hello"
foo="${foo} World"
echo "${foo}" #=> Hello World

# Конкатенация строк через += оператор
A="X Y"
A+=" Z"
echo "$A" #=> "X Y Z"

# Мультипликация строк
repeatChar() {
  local input="$1"
  local count="$2"
  printf -v myString '%*s' "$count"
  printf '%s\n' "${myString// /$input}"
}
repeatChar abc 3 #=> abcabcabc



echo "                                     Преобразование строки в массив"

# Рассплитить строку в массив по символу:
str="bla@some.com;john@home.com"
arr=(${str//;/ }) # заменяет все вхождения ';'(первоначальное //слово означает глобальную замену) в строке IN на ' ', , а затем интерпретирует строку, разделенную пробелами, как массив (это то, что делают окружающие круглые скобки).
echo ${arr[@]}   #=> bla@some.com john@home.com
echo ${arr[1]}   #=> john@home.com



echo "                                             Решения разные"

# Сортировка строки:
# 1. вставим в строку пробелы между каждым символом
str=''
for (( i = 0; i < ${#1}; ++i)); do
  str="$str ${1:$i:1}"
done
# 2. Рассплитить строку в массив по пробелам
a=(${str// / })
# 3. Сортировка массива(передаем цикл в sort)
b=($(for s in ${a[@]}; do echo $s; done | sort))
# 4. Удалим пробелы между символами


# ПОСЧИТАТЬ ЧИСЛО УНИКАЛЬНЫХ СИМВОЛОВ ЧТО ПОВТОРЯЮТСЯ В СТРОКЕ:
# 1. вставим в строку пробелы между каждым символом, рассплитим строку в массив по пробелам и произведем сортировку массива(передаем цикл в sort) - тоесть выполним пункты 1, 2 и 3 из примера "Сортировка строки"
# 2. Преобразуем массив в строку добавив пробелы только между разными символами
str=''
last=''
for el in "${b[@]}"; do
  if [ "$el" == "$last" ]; then
    str+="$el"
  else
    str+=" $el"
  fi
  last="$el"
done
# 3. Разобьем строку в массив и сосчитаем число элементов длинной больше 1
a=(${str// / })
count=0
for el in "${a[@]}"; do
  if [ "${#el}" -gt 1 ]; then
    let count+=1
  fi
done
echo $count













#
