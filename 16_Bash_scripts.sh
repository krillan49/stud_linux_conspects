echo "                                       Bash Shell скрипты"

# Bash Shell является усовершенствованной вариацией командного терминала

# Bash это интерпретатор

# Bash скрипт – файл с расширением .sh, что содержит список команд для выполнения в терминале ОС Линукс. При помощи Bash скрипта вы можете выполнять управление вашей операционной системой.

# $ bash --version                 - посмотреть версию GNU Bash

# Создаем фаил скрипта любым удобным способом. Название любое. Расширение - .sh. Для создания скрипта можно использовать любой текстовый редактор. Например nano.

# В скриптах можно описывать любые команды, терминала. При запуске файла все команды будут выполнены друг за другом в терминале.


# $ ./script.sh                    - выполнить скрипт только если есть права 'x' на этот фаил(можно поставить например a+x)
# $ bash script.sh                 - выполнить скрипт даже без прав 'x' на этот фаил


exit 0  # остановить скрипт например в зависимости от условия


# Запустить скрипт на Руби
script="
print ['z', *'a'..'z']['$1'.chars.sum { |x| x.ord - 96 } % 26]
"
echo $script | ruby



echo "                                           Базовый синтаксис"

# 1. В фаиле баш-скрипта в самом верху нужно обязательно(? почемуто работает и без) прописать закомментированную строку, чтобы система поняла что это именно баш-скрипт:
#!/bin/bash
#!/bin/bash -e               # вариант с кодварс

# 2. Далее можем писать любые команды, каждую с новой строки и они будут выпонены по порядку, когда будет запущен скрипт. Например:
ls
mkdir folder
echo "folder done"      # в скрипте аргумент echo обязательно в 2йных кавычках
touch folder/index.html
tree
xterm &                 # & - чтобы не ждать выполнения этой команды(тут запуск терминала) и выполнять скрипт дальше
echo "All done"

# 3. Далее сохраняем фаил скрипта, заходим в терминал и запускаем его
# $ bash script.sh                 - выполнить баш скрипт



echo "                                              Переменные"

# Чтобы создать переменную нужно указать ее название(нельзя использовать только спецсимволы), присваиваем в нее значение при помощи символа "=" (между символами не должно быть пробелов). Можно установить любое значение:
num=6                # переменная с целым числом
NUM2=45.5            # с флоат числом   (! bash не поддерживает числа с плавающей запятой !)
str="Vasya"          # со строкой(обязательно в 2йных кавычках)
com=`ls`             # с выводом команды(обязательно в косых кавычках). ? Любая по сложности команда или набор команд ?

# $ перед именем переменной берет ее значение
per="Inter is $num"  # интерполяция переменной в строку при помощи символа "$" и присвоение в другую переменную

compname=`hostname`
ping -c 4 $compname  # применяем переменную как параметр в команде

# Чтобы вывести переменную на экран, можно воспользоваться интерполяцией в строку оператора echo,
echo -n "Per is $num..."     #=> Per is 6...
# -n  - этот флаг в скрипте просто не добавит энтер и следующая строка пойдет сразу
echo "Per is $com"           #=> выведет название фаила и все фаилы и папки в столбик
echo "$str is $NUM2"         #=> Vasya is 45.5

# Зарезервированные переменные:
# $0  - содержит название фаила в котором записана
echo "$0"              #=> script.sh



echo "                                       Строковые операции"

# Строки в shell - это по умолчанию любые введенные символы.

str="123abc"
# length/длинна строки данных ${#parameter}
echo ${#str} #=> 6

# Срез вида ${parameter:offset} или ${parameter:offset:length}, где offset - индекс начала среза, length - число символов в срезе
echo ${str:1}    #=> "23abc"
echo ${str:2:2}  #=> "3a"
echo ${str:0:1}  #=> "1"    # тоесть элемент с индексом 0
echo ${str:1:-1} #=> "23ab" # при отрицательном length убирается число элементов с конца строки

# Можно использовать например в цикле
for (( i = 0; i < ${#str}; ++i)); do
  echo "${str:$i:1}"
done


# Получить 1й символ строки
first_letter=$(printf %.1s "abc")
echo "$first_letter" #=> 'a'

# Удалить 1й и последний символ строки при помощи команды sed и регулярок
echo '1234567' | sed -e 's/^.//' -e 's/.$//'    #=> '23456'

# Удаляем все пробелы с флагами "g" и "i"
echo "$1" | sed -e 's/ //gi'
echo "$1" | tr -d " " # тоже самое
echo ${1// /}      # тоже самое но работает лучше со спцсимволами
echo "${1//[aeiouAEIOU]/}" # удаляем все гласные

# Соответсвие. Както криво работает в условном операторе
"$text" =~ '^[+-]?[0-9]+$'


# Получить ascii код символа
char="a"
ascii_value=$(printf "%d" "'$char")
echo $ascii_value #=> 97


# Рассплитить строку в массив по символу:
IN="bla@some.com;john@home.com"
arrIN=(${IN//;/ }) # заменяет все вхождения ';'(первоначальное //слово означает глобальную замену) в строке IN на ' ', , а затем интерпретирует строку, разделенную пробелами, как массив (это то, что делают окружающие круглые скобки).
echo ${arrIN[1]}   #=> john@home.com


# Реверсировать строку
echo "$IN" | rev    #=> cba

# Сложение строк через интерполяцию
foo="Hello"
foo="${foo} World"
echo "${foo}" #=> Hello World

# tr - команда
echo "BAAACCC" | tr 'ABC' '123' #=> 2111333


echo "                                 Математические операции с Integer"

# https://www.shell-tips.com/bash/math-arithmetic-calculation

a=1
b=2

# Оболочка Bash имеет арифметические операторы для выполнения математических вычислений. Они работают с методами let, declareи и арифметического расширения
# + - * / ** %    - математические операторы(деление целочисленное)

# Чтобы осуществить математическую операцию над переменными, нужно:

# 1. Арифметическое расширение Bash - заключить ее в "$((операция))"
res=$((a+b))    # можно как без $
res=$(($a+$b))  # так и с $

# 2. Использование встроенных команд оболочки let или Declare
let a=5
let a+=1
let a++

# 3. При помощи команды expr
res=$(expr $a % 2)   # пробелы обязательны
c=`expr $a * $b`



echo "                                   Математические операции с Float"

# bash не поддерживает числа с плавающей запятой

# 1. способ выполнения арифметических операций с плавающей запятой в собственном bash — это объединение арифметического расширения с printf с использованием научной записи. Нужно применить заданный множитель в степени 10 к вашей математической операции внутри арифметического расширения, а затем использовать printf для отображения числа с плавающей запятой.

# printf %.<precision>f "$((10**<multiplier> * 2/3))e-<multiplier>"
printf %.3f "$((10**3 * 2/3))e-3"   #=> 0.666
# %.3f - тут 3 точность(число знаков после запятой). Если она будет выше чем сам множитель, то заполнится нулями
# 10**3 и e-3 - должно быть одно и тоже число
printf %.1f "$((10**3 * 2/3))e-3"   #=> 0.7
printf %.5f "$((10**3 * 2/3))e-3"   #=> 0.66600


# 2. Можно использовать команду 'bc' в неинтерактивном режиме, используя STDIN для отправки формулы, чтобы bc затем получил выходные данные STDOUT
echo "15.6+299.33*2.3/7.4" | bc  #=> 108.6
bc <<< "15.6+299.33*2.3/7.4"     #=> 108.6

# Параметр scale=n; переводит целые во float и указывает число знаков после запятой
echo "(2/3)+(7/8)" | bc          #=> 0
echo "scale=2;(2/3)+(7/8)" | bc  #=> 1.53
echo "scale=4;(2/3)+(7/8)" | bc  #=> 1.5416
echo "scale=6;(2/3)+(7/8)" | bc  #=> 1.541666

# Флаг -l позволяет перевести во float и увидеть результат с максимальным числом знаков после запятой
echo "(2/3)+(7/8)" | bc -l       #=> 1.54166666666666666666

# Подстановка в переменную
p1=$(echo "$p0 + $p0 * $percent * 0.01 + $aug" | bc -l)
p1=$(bc <<< "$p0 + $p0 * $percent * 0.01 + $aug")



echo "                                               Массивы"

arr=("" "kiwi" "pear" "kiwi" "banana" "melon")
echo ${arr[@]}  #=> "" "kiwi" "pear" "kiwi" "banana" "melon"
echo ${arr[1]}  #=> "kiwi"
echo ${arr[2]}  #=> "pear"
echo ${arr[4]}  #=> "banana"

# Переопределение элементов по индексу
arr[0]="AAA"
echo ${arr[@]} #=> "AAA" "kiwi" "pear" "kiwi" "banana" "melon"

# Длинна массива
echo $(( ${#arr[@]} ))      #=> 6
echo $(( ${#arr[@]} -1 ))   #=> 5       # индекс последнего элемента

# Новый пустой массив
res=()

# массив с результатами операций над переменными
arr=($((a+b+c)) $((a-b-c)))

# Обход массива через цикл
categories=("men" "women" "kids")
for word in "${categories[@]}"; do
  echo $word;
done

# Создание реверсированного массива
arr=("kiwi" "pear" "kiwi" "banana" "melon")
res=()
size=$(( ${#arr[@]} ))
for (( i=0; i<=$size; i++ )); do
  res[$i]="${arr[$((size-i))]}"
done
echo ${res[@]} #=> melon banana kiwi pear kiwi



echo "                                    Получение данных от пользователя"

# 1. Через нумерованные переменные

# Чтобы получить значение от передаваемых пользователем параметоров, нужно обратиться к нумерованной переменной например $1 или $2 или $7 итд, которая содержит 1й, 2й, 7й итд передаваемый пользователем в скрипт параметр. Те 0 сам скрипт, потом параметры (?тоесть нумерация просто всех слов в строке команды?)
a=$1                  # присваиваем 1й передаваемый параметр в переменную (хотя можно использовать и так)
b=$2
str=$3
res=$((a+b))
echo "$str is $res"

# Если пользователь не передаст параметр то значение по умолчанию будет == 0"

# Чтобы пользователю передать данные для параметров нужно ввести их через пробел при запуске скрипта, для передачи строковых параметров не нужны кавычки, кроме одинарных если содержатся пробелы
# $ bash script.sh 10 15 Result        #=> Result is 25
# $ bash script.sh 20 15 Scuf          #=> Scuf is 35


# 2. Через команду read - считывание от пользователя с введением параметра после запуска скрипта и того как он дойдет до строки с этой командой

# В 2 строки
echo "Enter the number: "
read num

# В одну стоку
read -p "Enter the number: " num
# "Enter the number " - сообщение которое увидит пользователь в консоли
# num - переменная примет значение которое введет пользователь

echo "Your number is $num"

# Далее при запуске скрипта пользователь получит в терминале сообщение и возможность ввести параметр после него
# $ bash script.sh
#=> Enter the number:     # далее в этой же строке пользователь вводит параметр (например 6) нажимает энтер
#=> Your number is 6


# Эти 2 способа получения переменных можно комбинировать



echo "                                         Условные операторы"

# 1. Условный оператор if, далее квадратные скобки с пробелами(можно больше 1 для выравнивания) вокруг, далее условия (?? переменные лучше выводить в кавычках так будут подставляться значения переменных, но работает нормально и без кавычек ??)

# операторы ==, > или < используется ТОЛЬКО для сравнения строк, чля чисел они работают некорректно
# Операторы сравнения для чисел (? только целых):
# ==   это   -eq        хотя == так же работает
# >    это   -gt
# >=   это   -ge
# <    это   -lt
# <=   это   -le

read -p "Enter the number: " num

if [ "$num" -eq 5 ]; then    # далее исполняемый код с новой строки, тут например стандартную команду
  ls
elif [ "$num" -gt 10 ]; then # elif - дополнительное условие
  echo "Your number greater then 10"
elif [ "$a" == "0" ] && [ "$b" == "0" ]; then # сложное условие
  echo true
elif (( $1 % $2 -eq 0 && $1 % $3 -eq 0 )); then # сложное условие вариант 2
  printf 'true\n'
elif [ "$(expr $num % 2)" -eq 0 ]; then echo "Even"   # можно писать в строку если только одна строка
else                        # после else уже не нужно писать "; then" (? если одна строка можно писать в одну строку)
  read -p "Enter your name: " name
  echo "$name"
fi                          # fi - закрывает условный оператор if

# $ bash script.sh
#=> Enter the number: 16
#=> Your number greater then 10

if [[ "$text" =~ ^[+-]?[0-9]+$ ]]; then # почемуто тут 2йные
  return 0
fi

# Сложное условие работает похоже на тернарный оператор
[[ $(($1 % $2)) -eq 0 && $(($1 % $3)) -eq 0 ]] && echo "true" || echo "false"


# Тернарный оператор
echo $(($1 ? 6 * $1 ** 2 + 2 : 1))


# 2. Условный оператор case
case $1 in # далее пишем все условия-соответсвия с новой строки и за ними скобку
       1) echo "one";;               # равен числу
   [2-9]) echo "two-nine";;          # входит в диапазон
  "Soso") echo "privet Soso";;       # равен строке
       *) echo "wrong parametr";;    # * - аналог else
esac # закрываем словом наоборот
# $ bash script.sh 1       #=> one
# $ bash script.sh 6       #=> two-nine
# $ bash script.sh Soso    #=> privet Soso
# $ bash script.sh aaa     #=> wrong parametr



echo "                                         Циклы: for и while"

# 1. Цикл while
i=0
while [ $i -lt 10 ]; do
  echo "El = $i"
  i=$(($i+1))
done


# 2. Цикл for
for (( i=1; i<=10; i++ )); do  # пробелы вокруг скобок обязательны
  echo "El = $i"
done                           # ключевое слово закрытия цикла
for (( i=1; i<=$n; i++ )); do  # с интерполяцией
  string="$string$2"
done

# Альтернативный синтаксис for с использованием диапазона
for i in {2..5}; do   # тоесть присваиваем в переменную i значения от 2х до 5
  echo "El = $i"
done
# почемуто не интерполируктся в такой {2..5} диапазон

echo "Count: "{1..20} # аналог того что выше

# Можно применить к обходу вывода команд
for file in `ls *.txt`; do   # все фаилы из вывода команды будут передаваться в переменную по очереди
  cat $file
done
# тут работает и без ls
for file in *.txt; do
  cat $file
done
# В 1 строку
for i in `seq 1 $n`; do echo -n $string; done  # seq 1 $n   - от 1 до n




echo "                                          Функции(?процедуры?)"

# Функция создается без ключевых слов просто название()

divide() {   # ?? скобки в принципе не принмают параметры ??
  echo "Params: $0 $1 $2" # Нумерованные параметры в теле функции, передаются при вызыве функции, а не просто скрипта, тк это локальная область видимости функции. Но параметр 0 все равно имя скрипта

  a=5 # новые переменные объявленные в теле функции являются глобальными(те выходят в поле видимости всего скрипта)
  local b=3 # локальная переменная функции определяется через доп слово local

  echo "vars is $a $b"     #=> vars is 5 3

  if [ "$2" -eq 0 ]; then
    echo "ZerroError"
  else
    res=$(($1/$2))
    echo "Res is $res"
  fi

  # Нет ретурна, те ничего не возвращается, значит это не функция а процедура ??
}

echo "vars is $a $b"   #=> vars is 5       # не будет ошибки если переменная не определена

divide 10 2  # вызов функции, после названия параметры через пробел, круглые кобки не нужны
divide 10 0  # еще 1 вызов

k=$(divide $a 5) # присвоение в переменную результата функции

# Далее запускаем в терминале
# $ bash script.sh
#=> Params: script.sh 10 2
#=> Res is 5
#=> Params: script.sh 10 0
#=> ZerroError


some_func "$@"  # так мы передаем все параметры скрипта в функцию под теми же нормерами, которые можем там использовать



# Тру функции
set -e # хз зачем ??

function ensure_integer() {
  local text=$1
  if [[ "$text" =~ ^[+-]?[0-9]+$ ]]; then
    return 0
  fi
  printf 1>&2 '%s is Not an Integer Number\n' "$text"
  return 1
}
function even_or_odd() {
  local num=$1
  ensure_integer "$num"
  local rr=(Even Odd)
  printf '%s' "${rr[(("$num" & 0x1))]}"
}
even_or_odd $1


function removeChar() {
  str=$1
  echo ${str:1:-1}
}
removeChar $1 # вызов функции


# Функция возвращает функцию
function Solution {
  function main {
    echo "Hello World!"
  }
  main
}
Solution

















#
