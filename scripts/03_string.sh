echo "                                              Строки"

# Строки в shell - это по умолчанию любые введенные символы.

str="123abc" # присвоение строки в переменную



echo "                                        Методы информационные"

# ${#parameter} - длинна строки
echo ${#str} #=> 6

# =~ - оператор проверки соответсвия строки шаблону. Как-то криво работает в условном операторе
"$text" =~ '^[+-]?[0-9]+$'

# Получить ascii код символа
char="a"
ascii_value=$(printf "%d" "'$char")
echo $ascii_value #=> 97



echo "                                        Элементы и срезы строк"

# ${parameter:offset:length} - синтаксис срезов строки где:
# offset - индекс начала среза(или число элементов до среза ??)
# length - число символов в срезе
echo ${str:1}    #=> "23abc"
echo ${str:2:2}  #=> "3a"
echo ${str:0:1}  #=> "1"    # тоесть элемент с индексом 0
echo ${str:1:-1} #=> "23ab" # при отрицательном length убирается число элементов с конца строки

# Получить n-й символ строки:
first_letter=$(printf %.1s "abc")
echo "$first_letter" #=> 'a'

# Длинну и срезы можно использовать например в цикле
for (( i = 0; i < ${#str}; ++i)); do
  echo "${str:$i:1}"
done



echo "                                      Методы трансформации строк"

# tr - команда для замены посимвольно
echo "BAAACCC" | tr 'ABC' '123' #=> 2111333

# upper/lower case
echo "AbC" | tr [A-Z] [a-z]             #=> "abc"
echo "AbC" | tr 'a-z' 'A-Z'             #=> "ABC"
echo "AbC" | tr '[:upper:]' '[:lower:]' #=> 'abc'
echo "AbC" | awk '{print tolower($0)}'  #=> 'abc'

# ${str~~} - оператор bash для swapcase строки
in=AbCdE
echo ${in~~} #=> aBcDe

# rev - команда для реверсирования строки
echo "abc" | rev        #=> "cba"
FOO=$(echo $str | rev)  # поместить реверсированную строку в переменную



echo "                                    Удаление частей строк по шаблонам"

# Удалить 1й и последний символ строки при помощи команды sed и регулярок
echo '1234567' | sed -e 's/^.//' -e 's/.$//'    #=> '23456'

str=" AbC dE "
echo "$str" | sed -e 's/ //gi'   #=> "AbCdE"   # Удаляем все пробелы с флагами "g" и "i"
echo "$str" | tr -d " "          #=> "AbCdE"   # тоже самое
echo ${str// /}                  #=> "AbCdE"   # тоже самое
echo "${str//[aeiouAEIOU]/}"     #=> " bC d "  # удаляем все гласные

# Подстанока переменной в регулярку (удаляем все буквы кроме указанных)
str="fuck"
abc="abcdefghijklmnopqrstuvwxyz"
echo "${abc//[^$str]/}" #=> cfku



echo "                                    Конкатенация и мультипликация строк"

# Конкатенация строк через интерполяцию
foo="Hello"
foo="${foo} World"
echo "${foo}" #=> Hello World

# Конкатенация строк через += оператор
A="X Y"
A+=" Z"
echo "$A" #=> "X Y Z"

# Мультипликация строк
repeatChar() {
  local input="$1"
  local count="$2"
  printf -v myString '%*s' "$count"
  printf '%s\n' "${myString// /$input}"
}
repeatChar abc 3 #=> abcabcabc



echo "                                     Преобразование строки в массив"

# ($str) - обрамление в круглые скобки интерпритирует строку как массив(если не переменная то пишем без кавычек), пробелы при интерпритации считаются разделителями на элементы массива
str="aa bbb cccc"
arr=($str)        # строка преобразуется в массив
echo ${arr[@]}    #=> aa bbb cccc
echo ${arr[1]}    #=> "bbb"

# Чтобы рассплитить строку в массив не по пробелу, а по другому символу, то сперва нужно заменить его на пробел (?? правда хз тогда что делать с изначальными пробелами ??):
str="bla@some.com;john@home.com"
arr=(${str//;/ }) # заменяет все вхождения ';'(первоначальное //слово означает глобальную замену) в строке на ' ', а затем интерпретирует строку, разделенную пробелами, как массив
echo ${arr[@]}   #=> bla@some.com john@home.com
echo ${arr[1]}   #=> john@home.com


# Разбиваем строку на массив всех символов 1
string="Hello"
array=($(echo "$string" | sed -e 's/./& /g'))
# `sed -e 's/./& /g'` - заменяет каждый символ сам на себя, добавляя пробел после каждого символа, что позволяет создать список символов
# array=($(...)) - помещает результат в массив

# Разбиваем строку на массив всех символов 2
string="Hello"
array=($(echo "$string" | fold -w1))
# fold -w1 - разбивает строку на строки по одному символу.



echo "                                             Решения разные"

# Сортировка строки:
# 1. вставим в строку пробелы между каждым символом
str=''
for (( i = 0; i < ${#1}; ++i)); do
  str="$str ${1:$i:1}"
done
# 2. Рассплитить строку в массив по пробелам
a=(${str// / })
# 3. Сортировка массива(передаем цикл в sort)
b=($(for s in ${a[@]}; do echo $s; done | sort))
# 4. Удалим пробелы между символами


# ПОСЧИТАТЬ ЧИСЛО УНИКАЛЬНЫХ СИМВОЛОВ ЧТО ПОВТОРЯЮТСЯ В СТРОКЕ:
# 1. вставим в строку пробелы между каждым символом, рассплитим строку в массив по пробелам и произведем сортировку массива(передаем цикл в sort) - тоесть выполним пункты 1, 2 и 3 из примера "Сортировка строки"
# 2. Преобразуем массив в строку добавив пробелы только между разными символами
str=''
last=''
for el in "${b[@]}"; do
  if [ "$el" == "$last" ]; then
    str+="$el"
  else
    str+=" $el"
  fi
  last="$el"
done
# 3. Разобьем строку в массив и сосчитаем число элементов длинной больше 1
a=(${str// / })
count=0
for el in "${a[@]}"; do
  if [ "${#el}" -gt 1 ]; then
    let count+=1
  fi
done
echo $count













#
