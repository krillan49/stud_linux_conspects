echo "                                         Условные операторы"

# 1. Условный оператор if, далее квадратные скобки с пробелами(можно больше 1 для выравнивания) вокруг, далее условия (?? переменные лучше выводить в кавычках так будут подставляться значения переменных, но работает нормально и без кавычек ??)

# операторы ==, > или < используется ТОЛЬКО для сравнения строк, чля чисел они работают некорректно
# Операторы сравнения для чисел (? только целых):
# ==   это   -eq        хотя == так же работает
# >    это   -gt
# >=   это   -ge
# <    это   -lt
# <=   это   -le

read -p "Enter the number: " num

if [ "$num" -eq 5 ]; then    # далее исполняемый код с новой строки, тут например стандартную команду
  ls
elif [ "$num" -gt 10 ]; then # elif - дополнительное условие
  echo "Your number greater then 10"
elif [ "$a" == "0" ] && [ "$b" == "0" ]; then # сложное условие
  echo true
elif (( $1 % $2 -eq 0 && $1 % $3 -eq 0 )); then # сложное условие вариант 2
  printf 'true\n'
elif [ "$(expr $num % 2)" -eq 0 ]; then echo "Even"   # можно писать в строку если только одна строка
else                        # после else уже не нужно писать "; then" (? если одна строка можно писать в одну строку)
  read -p "Enter your name: " name
  echo "$name"
fi                          # fi - закрывает условный оператор if

# $ bash script.sh
#=> Enter the number: 16
#=> Your number greater then 10

if [[ "$text" =~ ^[+-]?[0-9]+$ ]]; then # почемуто тут 2йные
  return 0
fi

# Сложное условие работает похоже на тернарный оператор
[[ $(($1 % $2)) -eq 0 && $(($1 % $3)) -eq 0 ]] && echo "true" || echo "false"


# Тернарный оператор
echo $(($1 ? 6 * $1 ** 2 + 2 : 1))


# 2. Условный оператор case
case $1 in # далее пишем все условия-соответсвия с новой строки и за ними скобку
       1) echo "one";;               # равен числу
   [2-9]) echo "two-nine";;          # входит в диапазон
  "Soso") echo "privet Soso";;       # равен строке
     ab*) echo "wrong parametr";;    # строки начинающиеся на ab
       *) echo "wrong parametr";;    # * - что угодно - аналог else
esac # закрываем словом наоборот
# $ bash script.sh 1       #=> one
# $ bash script.sh 6       #=> two-nine
# $ bash script.sh Soso    #=> privet Soso
# $ bash script.sh aaa     #=> wrong parametr





# Использование переменных в операторах if

# Bash позволяет == использовать его для равенства с [, но это не является стандартным (кавычки для $x необязательны:)
if [[ "$x" == "valid" ]]; then
  echo "x has the value 'valid'"
fi

# Вар2 кавычки для $x обязательны
if [ "$x" = "valid" ]; then # для проверки не совпадения, замените = на !=
  echo "x has the value 'valid'"
fi
# Вам нужны кавычки $x, потому что, если он пуст, ваш сценарий Bash обнаружит синтаксическую ошибку, как показано ниже:
if [ = "valid" ]; then


# Проверка существования фаила
x=`find . -type f -name "$1"`
if [ "$1" = "" ]; then
  echo "Nothing to find"
elif [ "$x" = "" ]; then
  echo "Can't find $1"
else
  echo "Found $1"
fi
# Тоже что и выше ? -z - проверка на отсудствие параметра или пустую строку ?
[ -z $1 ] && echo "Nothing to find" || [ -e $1 ] && echo "Found $1" || echo "Can't find $1"












#
